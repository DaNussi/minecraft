/* groovylint-disable CompileStatic, NestedBlockDepth, VariableTypeRequired */

def changedEggFiles = [] as LinkedList<String>
def eggConfigs = [] as LinkedList<Map>
def PELICAN_USER_ID = ''

pipeline {
    agent any

    environment {
        PELICAN_BASE_URL = credentials('jenkins-pelican-base-url')
        PELICAN_USER    = credentials('jenkins-pelican-user')
        PELICAN_TOKEN = credentials('jenkins-pelican-token')
    }

    stages {
        stage('Validate environment variables') {
            steps {
                script {
                    if (PELICAN_BASE_URL?.trim()?.length() == 0) {
                        error 'PELICAN_BASE_URL parameter is required'
                    }
                    if (PELICAN_USER?.trim()?.length() == 0) {
                        error 'PELICAN_USER parameter is required'
                    }
                    if (PELICAN_TOKEN?.trim()?.length() == 0) {
                        error 'PELICAN_TOKEN parameter is required'

                    }
                }
            }
        }

        stage('Resolve pelican user id') {
            steps {
                script {
                    def response = sh(
                        script: 'curl -s -o .jenkins/user-request.json -w "%{http_code}\n" -X GET -H "Accept: application/json" -H "Authorization: Bearer $PELICAN_TOKEN" -- $PELICAN_BASE_URL/users',
                        returnStdout: true
                    ).trim()

                    if(response.startsWith('2')) {
                        echo 'Successfully retrieved pelican users'
                        def usersJson = readJSON file: '.jenkins/user-request.json'
                        def pelicanUsers = usersJson['data'].collect { userJson ->
                            [
                                id: userJson['attributes']['id'],
                                username: userJson['attributes']['username'],
                                email: userJson['attributes']['email']
                            ]
                        }

                        echo "Found ${pelicanUsers.size()} users"

                        // Match by email (case-insensitive), fall back to username if not found.
                        def target = PELICAN_USER?.trim()?.toLowerCase()
                        def matchedUsers = pelicanUsers.findAll { u ->
                            (u.email ?: '').toLowerCase() == target
                        }

                        if (matchedUsers.size() == 1) {
                            def pelicanUser = matchedUsers[0]
                            // store globally for later stages
                            PELICAN_USER_ID = pelicanUser.id
                            echo "Resolved Pelican user id: ${PELICAN_USER_ID} for user: ${pelicanUser.username} (${pelicanUser.email})"
                        } else if (matchedUsers.size() > 1) {
                            error "Multiple Pelican users matched '${PELICAN_USER}'. Please ensure the PELICAN_USER email is unique."
                        } else {
                            error "No Pelican user matched '${PELICAN_USER}'. Please ensure PELICAN_USER credential contains the user's email (or username)."
                        }


                    } else {
                        error "Failed to retrieve pelican users, response code: ${response}"
                    }

                    echo response
                }
            }
        }

        stage('Detect egg changes') {
            steps {
                script {
                    def targetBranch = env.CHANGE_TARGET ?: 'main'
                    echo "Comparing changes against branch: origin/${targetBranch}"

                    sh 'git show-ref'

                    def eggsConfig = readJSON file: '.jenkins/eggs.json'

                    changedEggFiles = []
                    eggConfigs += eggsConfig['eggs']

                    eggConfigs.each { eggConfig ->
                        echo "Found egg configuration: ${eggConfig}"

                        String currentChangedEggDiffs = sh(
                            script: "git diff --name-only origin/${targetBranch} -- ${eggConfig['path']}",
                            returnStdout: true
                        )
                        .trim()

                        if (currentChangedEggDiffs.isEmpty() == false) {
                            def currentChangedEggFiles = currentChangedEggDiffs
                                .split('\n')
                                .findAll { file -> file.endsWith('.json') }
                                //.findAll { file -> file.endsWith('.json') && fileExists(file) }

                            echo "Detected ${currentChangedEggFiles.size()} changed egg files in path: ${eggConfig['path']}"

                            changedEggFiles += currentChangedEggFiles
                        } else {
                            echo "No changes detected in egg path: ${eggConfig['path']}"
                        }
                    }

                    echo 'Changed egg file:'
                    changedEggFiles.each { changedEggFile ->
                        echo changedEggFile
                    }
                }
            }
        }

        stage('Process changed egg files') {
            when {
                expression { return changedEggFiles.size() > 0 }
            }
            steps {
                script {
                    def parallelStages = [:]
                    for (int pi = 0; pi < changedEggFiles.size(); pi++) {
                        def fileToProcess = changedEggFiles[pi]
                        // create a closure that will be executed in parallel
                        parallelStages["Process ${fileToProcess}"] = {
                            node {
                                stage("Process ${fileToProcess}") {
                                    echo "Processing egg file: ${fileToProcess}"
                                }
                            }
                        }
                    }

                    if (parallelStages.size() > 0) {
                        parallel parallelStages
                    }
                }
            }
        }
    }
}
