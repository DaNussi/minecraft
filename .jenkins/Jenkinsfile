/* groovylint-disable CompileStatic, NestedBlockDepth, VariableTypeRequired */

def hatchFileDescriptions = []
def hatchStages = [:]

pipeline {
    agent any

    environment {
        PELICAN_BASE_URL = credentials('jenkins-pelican-base-url')
        PELICAN_USER_ID = credentials('jenkins-pelican-user-id')
        PELICAN_TOKEN = credentials('jenkins-pelican-token')

        PELICAN_SECRET_CURSE_FORGE_API_KEY= credentials('jenkins-pelican-secret-curse-forge-api-key')
    }

    stages {
        stage('Validate environment variables') {
            steps {
                script {
                    if (PELICAN_BASE_URL?.trim()?.length() == 0) {
                        error 'PELICAN_BASE_URL parameter is required'
                    }
                    if (PELICAN_USER_ID?.trim()?.length() == 0) {
                        error 'PELICAN_USER_ID parameter is required'
                    }
                    if (PELICAN_TOKEN?.trim()?.length() == 0) {
                        error 'PELICAN_TOKEN parameter is required'

                    }
                }
            }
        }

        stage('Scan for configs') {
            steps {
                script {
                    hatchFileDescriptions = findFiles(glob: "**/*.hatch.json")
                }
            }
        }

        stage('Hatching Egg\'s') {
            steps {
                script {
                    for (def hatchFileDescription : hatchFileDescriptions) {
                        def hatchFile = hatchFileDescription.path
                        hatchStages["Hatching Egg ${hatchFile}"] = hatchEgg(hatchFile)
                    }
                    parallel hatchStages
                }
            }
        }

//        stage('Detect egg changes') {
//            steps {
//                script {
//                    def targetBranch = env.CHANGE_TARGET ?: 'main'
//                    echo "Comparing changes against branch: origin/${targetBranch}"
//
//                    sh 'git show-ref'
//
//                    def eggsConfig = readJSON file: '.jenkins/eggs.json'
//
//                    changedEggFiles = []
//                    eggConfigs += eggsConfig['eggs']
//
//                    eggConfigs.each { eggConfig ->
//                        echo "Found egg configuration: ${eggConfig}"
//
//                        String currentChangedEggDiffs = sh(
//                            script: "git diff --name-only origin/${targetBranch} -- ${eggConfig['path']}",
//                            returnStdout: true
//                        )
//                        .trim()
//
//                        if (!currentChangedEggDiffs.isEmpty()) {
//                            def currentChangedEggFiles = currentChangedEggDiffs
//                                .split('\n')
//                                .findAll { file -> file.endsWith('.json') }
//                                //.findAll { file -> file.endsWith('.json') && fileExists(file) }
//
//                            echo "Detected ${currentChangedEggFiles.size()} changed egg files in path: ${eggConfig['path']}"
//
//                            changedEggFiles += currentChangedEggFiles
//                        } else {
//                            echo "No changes detected in egg path: ${eggConfig['path']}"
//                        }
//                    }
//
//                    echo 'Changed egg file:'
//                    changedEggFiles.each { changedEggFile ->
//                        echo changedEggFile
//                    }
//                }
//            }
//        }
//
//        stage('Testing egg\'s'){
//            steps {
//                script {
//                    for (int pi = 0; pi < changedEggFiles.size(); pi++) {
//                        String eggFile = changedEggFiles[pi]
//                        eggTestingStages["Testing Egg ${eggFile}"] = testEgg(eggFile, eggIds, PELICAN_USER.id as Integer)
//                        break //for testing only
//                    }
//                    parallel eggTestingStages
//                }
//            }
//        }
    }
}


def hatchEgg(def hatchFile) {
    def eggFile = hatchFile.replace('.hatch.json', '.json')
    def hatch = [:]
    def egg = [:]
    def server = [:]

    return {
        stage("Hatching Egg ${hatchFile}") {

            stage("Checking hatch file") {
                echo "Checking if hatch file '${hatchFile}' exists and is valid..."
                script {
                    catchError(message : "Hatch file failed validation ${hatchFile}".toString(), buildResult: 'UNSTABLE', stageResult: 'NOT_BUILT', catchInterruptions: false) {
                        if(!fileExists(hatchFile)) error("Hatch file was not found '${hatchFile}'")
                        hatch = readJSON(file: hatchFile)
                        //TODO: Check secrets if they are available
                        echo "Hatch file '${hatchFile}' exsists and is valid!"
                    }
                }
            }

            stage("Checking egg file") {
                echo "Checking if egg file '${eggFile}' exists and is valid..."
                script {

                    catchError(message : "Egg file failed validation ${eggFile}".toString(), buildResult: 'UNSTABLE', stageResult: 'NOT_BUILT', catchInterruptions: false) {
                        if(!fileExists(eggFile)) error("Found egg file but no egg: ${eggFile}")
                        egg = readJSON(file: eggFile)
                        echo "Egg file '${eggFile}' exsists and is valid!"
                    }
                }
            }

            stage("Mark egg") {
                script {
                    catchError(message : "Failed to save egg ${eggFile}".toString(), buildResult: 'FAILURE', stageResult: 'FAILURE', catchInterruptions: false) {
                        String gitUUID = env.GIT_COMMIT as String
                        String fileUUID = eggFile
                        egg['uuid'] = UUID.nameUUIDFromBytes((fileUUID + '@' + gitUUID).getBytes()).toString()
                        writeJSON(file: eggFile, json: egg, pretty: 4)
                        echo "Set egg '${eggFile}' uuid to ${egg['uuid']}"
                    }
                }
            }

            stage("Importing egg") {
                echo "Importing egg file into the pelican panel: ${eggFile}"
                script {
                    catchError(message : "Failed to import egg ${eggFile}".toString(), buildResult: 'FAILURE', stageResult: 'FAILURE', catchInterruptions: false) {
                        def response = httpRequest url: "${env.PELICAN_BASE_URL}/eggs/import?format=json".toString(),
                                acceptType: 'APPLICATION_JSON',
                                contentType: 'APPLICATION_JSON',
                                httpMode: 'POST',
                                requestBody: (writeJSON(json: egg, returnText: true, pretty: 4) as String),
                                validResponseCodes: '200:299',
                                consoleLogResponseBody: true,
                                customHeaders: [[name: 'Authorization', value: "Bearer ${env.PELICAN_TOKEN}"]]
                        def body = readJSON text: response.content
                        egg['id'] = body['attributes']['id'] as int
                        echo "Successfully imported egg '${eggFile}' into the pelican panel with id: ${egg['id']}"
                    }
                }
            }

            stage("Creating server") {
                script {

                    def port_range = []
                    for (port in 25600..<25700) {
                        port_range.add(port.toString())
                    }

                    def secretEnvs = (hatch['secret'].properties ?: [:]).collectEntries { entry ->
                        entry.value = sh(returnStdout: true, script: "echo \$${entry.value}").trim()
                        return entry
                    }

                    server['name']="Jenkins ${env.JOB_BASE_NAME} ${env.BUILD_NUMBER}".toString()
                    server['external_id']=egg['uuid']
                    server['description']="Automated test server. Created by ${env.BUILD_URL}".toString()
                    server['user'] = env.PELICAN_USER_ID as Integer
                    server['egg'] = egg['id']
                    server['environment'] = [:]
                    server['environment'] += hatch['environment'] ?: [:]
                    server['environment'] += secretEnvs
                    server['skip_scripts'] = false
                    server['oom_killer'] = false
                    server['limits'] = [
                            'memory': 10240,
                            'swap': -1,
                            'disk': 4096,
                            'io': 1000,
                            'cpu': 800
                    ]
                    server['feature_limits'] = [
                            'databases': 0,
                            'allocations': 0,
                            'backups': 0,
                    ]
                    server['deploy'] = [
                            'dedicated_ip': false,
                            'tags': ['jenkins'],
                            'port_range': port_range
                    ]



                }
                echo "Creating server from egg: ${eggFile}"
                script {
                    catchError(message : "Failed to create server ${eggFile}".toString(), buildResult: 'FAILURE', stageResult: 'FAILURE', catchInterruptions: false) {
                        def response = httpRequest url: "${env.PELICAN_BASE_URL}/servers".toString(),
                                acceptType: 'APPLICATION_JSON',
                                contentType: 'APPLICATION_JSON',
                                httpMode: 'POST',
                                requestBody: (writeJSON(json: server, returnText: true, pretty: 4) as String),
                                validResponseCodes: '200:299',
                                consoleLogResponseBody: true,
                                customHeaders: [[name: 'Authorization', value: "Bearer ${env.PELICAN_TOKEN}"]]
                        def body = readJSON text: response.content
                        server['id'] = body['attributes']['id'] as int
                        echo "Successfully created server '${eggFile}' with id: ${server['id']}"
                    }
                }
            }


            stage("Deleting egg") {
                echo "Deleting egg ${egg['uuid']} '${eggFile}'"
                script {
                    catchError(message : "Failed to delete egg ${egg['uuid']} ${eggFile}".toString(), buildResult: 'SUCCESS', stageResult: 'NOT_BUILT', catchInterruptions: false) {
                        httpRequest url: "${env.PELICAN_BASE_URL}/eggs/${egg['uuid']}/uuid".toString(),
                                acceptType: 'APPLICATION_JSON',
                                contentType: 'APPLICATION_JSON',
                                httpMode: 'DELETE',
                                validResponseCodes: '200:299',
                                consoleLogResponseBody: true,
                                customHeaders: [[name: 'Authorization', value: "Bearer ${env.PELICAN_TOKEN}"]]
                        echo "Successfully deleted egg ${eggFile}"
                    }
                }
            }

        }
    }
}
